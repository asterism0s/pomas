**ddb**

Quack. I am CS50's duck debugger (ddb), an experimental AI for [rubberducking](https://en.wikipedia.org/wiki/Rubber_duck_debugging). Quack quack. My replies might not always be accurate, so always think critically and let me know if you think that I've erred. Conversations are logged. Quack quack quack.

**you**

Boa tarde, pato, voce sabe o que é uma tecnica de pomodoro né?

**ddb**

Boa tarde! Sim, conheço a técnica Pomodoro. É uma técnica de gerenciamento de tempo que envolve trabalhar em blocos de tempo, geralmente de 25 minutos, seguidos por uma pausa curta. Isso pode ajudar a manter o foco e a produtividade. Como posso ajudar com relação ao CS50 ou à ciência da computação?

**you**

Perfeito! Tou fazendo um timer de pomodoro, e já tenho a lógica do tempo de trabalho finalizada. Agora quero fazer a lógica de pausa.

Esse é o meu código de tempo de trabalho:

import './settings-modal.js';


import { getUserPomoTime } from './settings-modal.js';
import { timerStatus } from './timer-status.js';

const playBtn = document.getElementById('togglePlayControlBtn');
const stopBtn = document.querySelector('.play-controls__button--stop');
const skipBtn = document.querySelector('.play-controls__button--skip');

const minutesDisplay = document.querySelector('.timer-card__minutes--number');
const colon = document.querySelector('.timer-card__separator--colon');
const secondsDisplay = document.querySelector('.timer-card__seconds--number');

const workIcon = document.querySelector('.timer-card__status-work-icon');
const pauseIcon = document.querySelector('.timer-card__status-pause-icon');

let colonVisible = true;
let timerInterval;
let colonInterval;
export let pomoCounter;


stopBtn.style.display = 'none';
skipBtn.style.display = 'none';

// DEBUG: enquanto for true, usa 10 s em vez do valor real. para desativar debug, passe TEST_MODE = false
const TEST_MODE = true;
const TEST_SECONDS = 10;

let remainingTime = TEST_MODE ? TEST_SECONDS : getUserPomoTime() * 60;



export function setRemainingTime(seconds) {
remainingTime = TEST_MODE
? TEST_SECONDS
: seconds;
updateTimerDisplay(remainingTime);
};

//pega o tempo atual do timer
export function getRemainingTime() {
    return remainingTime;
}


export function updateTimerDisplay(seconds) {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60;

    minutesDisplay.textContent = String(mins).padStart(2, '0');
    secondsDisplay.textContent = String(secs).padStart(2, '0');
};




//END_TIMER DEBUG
function endTimer() {
    clearInterval(timerInterval);
    clearInterval(colonInterval);

    colon.style.visibility = 'visible';
    colonVisible = true;

    //desativar quando criar a breakTimer
    remainingTime = TEST_MODE ? TEST_SECONDS : getUserPomoTime() * 60;
    updateTimerDisplay(remainingTime);

    playBtn.classList.replace('play-controls__button--pause', 'play-controls__button--play');
    playBtn.setAttribute('aria-pressed', false);

    stopBtn.style.display = 'none';
    skipBtn.style.display = 'none';

};

function startTimer(){
    
    if(remainingTime === 0) {
        remainingTime = getUserPomoTime() * 60;
        // pomoCounter++
    }

    updateTimerDisplay(remainingTime);

    timerInterval = setInterval(() => {

        if (remainingTime > 0) {
            remainingTime--;
            updateTimerDisplay(remainingTime);

        } else {
            clearInterval(timerInterval);
            endTimer();
            
        }
    }, 1000); 
};


function pauseTimer() {
    clearInterval(timerInterval);
};

function displayColon() {

    if (colonVisible) {
        colon.style.visibility = 'hidden';
        colonVisible = false; 
    } else {
        colon.style.visibility = 'visible';
        colonVisible = true; 
    }

};

playBtn.addEventListener('click', () => {
    const isPlayState = playBtn.classList.contains('play-controls__button--play');
    

    if (isPlayState) {
        playBtn.classList.replace('play-controls__button--play', 'play-controls__button--pause');
        
        playBtn.setAttribute('aria-pressed', 'true');

        startTimer();
        
        colonInterval = setInterval(displayColon, 1000);

        stopBtn.style.display = 'none';
        skipBtn.style.display = 'none';

    } else {
        
        //quando o botão de play é pressionando para pausar o timer. 
        playBtn.classList.replace('play-controls__button--pause', 'play-controls__button--play');
        
        playBtn.setAttribute('aria-pressed', false);
        pauseTimer();

        clearInterval(colonInterval);

        colon.style.visibility = 'visible';
        stopBtn.style.display = 'inline-flex';
        skipBtn.style.display = 'inline-flex';
    }

});



//para o timer e reseta o tempo para o temop padrão
function stopTimer() {
    clearInterval(timerInterval);
    clearInterval(colonInterval);

    colon.style.visibility = 'visible';
    colonVisible = true;

    remainingTime = 10; // Reset to initial time
    updateTimerDisplay(remainingTime);

    playBtn.classList.replace('play-controls__button--pause', 'play-controls__button--play');
    playBtn.setAttribute('aria-pressed', false);

    stopBtn.style.display = 'none';
    skipBtn.style.display = 'none';
};

**ddb**

Parece que você já tem uma boa base para o seu timer de pomodoro! Agora, para adicionar a lógica de pausa, você pode criar uma função semelhante à `startTimer`, mas com o tempo de pausa. Você já tem alguma ideia de como começar?

**you**

Sim, então criei a getRemainingTime, que vai salvar o exato tempo restante de timer, e vou usa-la pra fazer a função de pausa. Já que preciso saber se o tempo acabou ou não. É uma boa?

**ddb**

Sim, isso parece uma boa ideia! A função `getRemainingTime` pode ser útil para verificar se o tempo acabou ou não. Você também pode criar uma variável para armazenar o tempo de pausa e uma função para iniciar o timer de pausa. Como você planeja implementar isso?

**you**

Pode me ajudar na implementação da função de pausa com um passo a passo detalhado?

**ddb**

Claro! Vamos pensar juntos. Primeiro, você pode criar uma variável para armazenar o tempo de pausa, semelhante à variável `remainingTime` que você já tem para o tempo de trabalho. Você já tem uma ideia de como fazer isso?

**you**

Ah, isso eu já tenho, olha só 

export function getUserShortBreak() {
    return localStorage.getItem('shortBreak');
};

**ddb**

Ótimo! Você já tem uma função para obter o tempo de pausa. Agora, podemos criar uma função para iniciar o timer de pausa, semelhante à função `startTimer`. Como você acha que podemos começar essa função?

**you**

Pensei em começar assim:

function startBreakTimer () {
    if (getRemainingTime() === 0) {
        
    }
}

**ddb**

Isso parece um bom começo! Na função `startBreakTimer`, podemos verificar se o tempo de trabalho acabou usando `getRemainingTime()`. Se sim, podemos iniciar o timer de pausa. Como você acha que podemos fazer isso?

**you**

Hm, então essa verificação precisa ser feita fora da função do startBreakTimer ou não é necessário?

**ddb**

A verificação pode ser feita dentro da função `startBreakTimer`. Quando o tempo de trabalho acaba, você pode chamar `startBreakTimer` para iniciar o timer de pausa. Isso faz sentido?

**you**

Assim?

function startBreakTimer () {
    if (getRemainingTime() === 0) {
        //pega o tempo selecionado pelo usuário e joga pra UI
        setRemainingTime = getUserShortBreak() * 60;

        //se sim Se sim, podemos iniciar o timer de pausa. 
    }
}

**ddb**

Sim, isso parece um bom começo! Você está pegando o tempo de pausa do usuário e configurando o tempo restante para o timer de pausa. Agora, como você planeja iniciar o timer de pausa?

**you**

Eu teria que inserir aqui né?

    timerInterval = setInterval(() => {

        if (remainingTime > 0) {
            remainingTime--;
            updateTimerDisplay(remainingTime);

        } else {
            clearInterval(timerInterval);
            endTimer();
            
        }
    }, 1000);

**ddb**

Sim, exatamente! Você pode usar `setInterval` para iniciar o timer de pausa, assim como fez para o timer de trabalho. Parece que você está no caminho certo!

**you**

Mas terá que ser dentro desse if e else né?

**ddb**

Sim, o `setInterval` deve estar dentro do `if` para iniciar o timer de pausa quando o tempo de trabalho acabar. E o `clearInterval` deve estar no `else` para parar o timer de pausa quando o tempo de pausa acabar. Isso faz sentido?